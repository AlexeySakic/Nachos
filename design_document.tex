\documentclass{article}
\usepackage{amsmath,amsfonts,amsthm,amssymb}
\usepackage{setspace}
\usepackage{paralist}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{extramarks}
\usepackage{chngpage}
\usepackage{soul,color}
\usepackage{graphicx,float,wrapfig}
\usepackage{mathrsfs}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{tikz}
\usepackage{pgffor}
\usepackage{listings}
\newcommand{\Class}{Operating System}
\newcommand{\ClassInstructor}{Xu Wei}

% Homework Specific Information. Change it to your own
\newcommand{\Title}{Nachos Phase 1 Design Document}
\newcommand{\DueDate}{March 11, 2014}
\newcommand{\StudentName}{Yin HeZheng}
\newcommand{\StudentClass}{Yao Class}
\newcommand{\StudentNumber}{2011012343}
\newcommand{\xd}{\leqslant}
\newcommand{\dd}{\geqslant}
% In case you need to adjust margins:
\topmargin=-0.45in      %
\evensidemargin=0in     %
\oddsidemargin=0in      %
\textwidth=6.5in        %
\textheight=9.0in       %
\headsep=0.25in         %

% Setup the header and footer
\pagestyle{fancy}                                                       %
\lhead{\StudentName}                                                 %
\chead{\Title}  %
%\rhead{\firstxmark}                                                     %
\lfoot{\lastxmark}                                                      %
\cfoot{}                                                                %
\rfoot{Page\ \thepage\ of\ \protect\pageref{LastPage}}                          %
\renewcommand\headrulewidth{0.4pt}                                      %
\renewcommand\footrulewidth{0.4pt}                                      %

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Some tools
\newcommand{\enterProblemHeader}[1]{\nobreak\extramarks{#1}{#1 continued on next page\ldots}\nobreak%
                                    \nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak}%
\newcommand{\exitProblemHeader}[1]{\nobreak\extramarks{#1 (continued)}{#1 continued on next page\ldots}\nobreak%
                                   \nobreak\extramarks{#1}{}\nobreak}%

\newcommand{\homeworkProblemName}{}%
\newcounter{homeworkProblemCounter}%
\newenvironment{homeworkProblem}[1][Problem \arabic{homeworkProblemCounter}]%
  {\stepcounter{homeworkProblemCounter}%
   \renewcommand{\homeworkProblemName}{#1}%
   \section*{\homeworkProblemName}%
   \enterProblemHeader{\homeworkProblemName}}%
  {\exitProblemHeader{\homeworkProblemName}}%

\newcommand{\homeworkSectionName}{}%
\newlength{\homeworkSectionLabelLength}{}%
\newenvironment{homeworkSection}[1]%
  {% We put this space here to make sure we're not connected to the above.

   \renewcommand{\homeworkSectionName}{#1}%
   \settowidth{\homeworkSectionLabelLength}{\homeworkSectionName}%
   \addtolength{\homeworkSectionLabelLength}{0.25in}%
   \changetext{}{-\homeworkSectionLabelLength}{}{}{}%
   \subsection*{\homeworkSectionName}%
   \enterProblemHeader{\homeworkProblemName\ [\homeworkSectionName]}}%
  {\enterProblemHeader{\homeworkProblemName}%

   % We put the blank space above in order to make sure this margin
   % change doesn't happen too soon.
   \changetext{}{+\homeworkSectionLabelLength}{}{}{}}%
\newcommand{\Proof}{\ \\\textbf{Proof:} }
\newcommand{\Answer}{\ \\\textbf{Answer:} }
\newcommand{\Acknowledgement}[1]{\ \\{\bf Acknowledgement:} #1}

\makeatletter
\newcommand{\rmnum}[1]{\romannumeral #1}
\newcommand{\Rmnum}[1]{\expandafter\@slowromancap\romannumeral #1@}
\makeatother
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Make title
\title{\textmd{\bf \Class: \Title}\\{\large Instructed by \textit{\ClassInstructor}}\\\normalsize\vspace{0.1in}\small{Due\ on\ \DueDate}}
\date{}
\author{\textbf{\StudentName}\ \ \StudentClass\ \ \StudentNumber}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\begin{spacing}{1.1}
\maketitle \thispagestyle{empty}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Begin edit from here

%tikz test
%\begin{tikzpicture}
%\draw (-2.0,0) -- (2.0,0);
%\draw[rotate=90] (0,0) ellipse (20pt and 10pt);
%\end{tikzpicture}

\theoremstyle{plain} \newtheorem{computational}{Definition}

\section{Task 5}

\subsection{Overview}
Task 5 asks us to implement priority scheduling in Nachos by completing the \texttt{PriorityScheduler} class. Particularly, in choosing which  thread to dequeue, the scheduler always choose a thread of the highest effective priority (choose the one that has been waiting in the queue longest if multiple threads with the same highest priority are waiting).

The most difficulty lies in the function \texttt{Scheduler.getEffectivePriority}. To calculate one thread's effective priority (abbr. EP), we have to maintain a priority queue representing all threads it is getting priority from. Notice that when a thread's EP changes, threads' EP which that thread is waiting on may change as well. So we also need to maintain which thread is it waiting on for each thread. 

Specifically, we calculate a thread's prior it  by taking the max of the donor's and the recipient's priority. As for the transitive property of priority donation, we simply call \texttt{Scheduler.getEffectivePriority} recursively.

To speed up the calculation of EP, we create a variable to cache EP in class \texttt{ThreadState}. Thus, we only need to recalculate a thread's effective priority when it is possible for it to change.

\subsection{Correctness Constraints}

\begin{asparaitem}
\item All threads waiting in a queue are sorted by their effective priority\\
\item All threads store a linked list of queues they own and its own effective priority for cache\\
\item The effective priority of a thread is calculated by taking max between its initial priority and the largest effective priority stored in the linked list of queues.\\
\item When a thread is selected from the queue to acquire the resource (\texttt{nextThread}) that thread is removed from the queue and the new thread is told to aquire the queue (\texttt{acquire}) The previous owner of the queue is told it no longer owns this queue, and this queue is removed from its linked list. At the same time, this queue is inserted into the linked list of new owner. The new owner of the queue gets the highest priority in the queue added to its priority cache and its effective priority updated. \\
\item When a thread is added to the waiting queue (\texttt{waitForAccess}), it may have the highest priority of all threads in the queue. The owner of the queue then needs to update its effective priority to be greater than or equal to the new waiting thread.\\
\item When a change occurs to a thread's effective priority, it must reinsert itself into the correct position in the queue and as a result may end up affecting the effective priority of that queue's owner.
\end{asparaitem}

\subsection{Declarations}

We use \texttt{LinkedList<PriorityQueue> waitBy} and \texttt{PriorityQueue waitOn} to store threads waiting us and threads we are waiting separately. The class \texttt{PriorityQueue} is implemented by java.util.PriorityQueue.

\subsection{Descriptions}

The following algorithm describes the implementation of \texttt{getEffectivePriority} in high level.

\begin{algorithm}
  \caption{calculate effective priority}
\begin{algorithmic}[1]
  \STATE Initialize EP and donatorEP as default priority
  \STATE EP $\leftarrow$ priority
\FORALL {wait queues whose resource has been acquired by me}
  \STATE donatorEP $\leftarrow$ largest EP in that wait queue
  \IF {donatorEP $>$ EP}
    \STATE EP $\leftarrow$ donatorEP
  \ENDIF
\ENDFOR
\STATE recursively call calculate effective priority on the thread I am waiting on
\RETURN EP
\end{algorithmic}
\end{algorithm}

To clarify how we manipulate data structure, we illustrate the implementation of function \linebreak \texttt{PriorityQueue.waitForAccess}, \texttt{PriorityQueue.acquire} and \texttt{PriorityQueue.nextThread} (actually, \linebreak \texttt{waitForAccess} and \texttt{acquire} are implemented in class \texttt{ThreadState}).

\begin{algorithm}
  \caption{\texttt{ThreadState.wairForAccess(PriorityQueue waitQueue)}}
\begin{algorithmic}[1]
  \STATE waitQueue.add(this)  \COMMENT{add this thread to waitQueue}
  \STATE this.waitingOn $\leftarrow$ waitQueue  \COMMENT{update waitingOn queue}
  \STATE this.EP $\leftarrow$ calculateEffectivePriority()  \COMMENT{update EP}
\RETURN 
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{\texttt{ThreadState.acquire(PriorityQueue waitQueue)}}
\begin{algorithmic}[1]
  \STATE waitQueue.owner $\leftarrow$ this
  \STATE this.waitingBy.insert(waitQueue)
  \STATE this.EP $\leftarrow$ calculateEffectivePriority()  \COMMENT{update EP}
\RETURN 
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{\texttt{nextThread}}
\begin{algorithmic}[1]
  \STATE Initialize chosenThread as null
  \STATE chosenThread $\leftarrow$ pickNextThread()
  \IF {chosenThread != null}
    \STATE remove this queue from current owner's waitingBy list
    \STATE chosenThread.waitingOn $\leftarrow$ null
    \STATE insert this queue into chosenThread's waitingBy list
  \ENDIF
  \STATE this.owner $\leftarrow$ chosenThread
\RETURN chosenThread
\end{algorithmic}
\end{algorithm}

\subsection{Testing Plan}

\section{Task 6}

\subsection{Design Decisions}
Let's look at the problem more closely. Consider the simplest case where there are 2 children and 1 adult on Oaku. The only feasible way to carry them to Molokai is as follows:
\begin{asparaitem}
  \item Two children go to Molokai, one rowing the boat and the other riding it.\\
  \item One child rows the boat back to Oahu.\\
  \item The adult rows to Molokai.\\
  \item The child left on Molokai rows the boat back to Oahu.\\
  \item Two children go to Molokai.\\
\end{asparaitem}

Compare this to the scheme to carry 3 children:
\begin{asparaitem}
  \item Two children go to Molokai, one rowing the boat and the other riding it.\\
  \item One child rows the boat back to Oahu.\\
  \item Two children go to Molokai.\\
\end{asparaitem}

Ignoring the two final steps of these two subroutines, those two subroutines carry one adult and one child from Oahu to Molokai respectively, using two children as a medium. Therefore, once we have two children and a boat on Oahu, we can repeatedly carry other adults and children to Molokai using the two subrountines above until there are only two children left on Oaku, then let them go across the sea by themselves.\\

Having understood this, it is reasonable to assign roles to all the adults and children. More specificly, we have the following role assignment:
\begin{asparaitem}
  \item \textbf{Rower}: The child who is responsible to row the boat. We denote it by $R$.\\
  \item \textbf{Rider}: The child who is responsible to ride the boat of the rower. We denote it by $D$.\\
  \item Other people who are going to be carried by $R$ and $D$.\\
\end{asparaitem}

\subsection{Designed Strategy}
Then the main idea can be expressed as follows:
\begin{asparaitem}
  \item We store the total number of adults and children in a global variable. Each time a person is created, the counter increases by one.\\
  \item All the children try to acquire the rower role, and only one of them get it. $R$ then decrease the population counter by 1.\\
  \item Those who failed to get the rower role try to acquire the rider role, and only one of them get it. $D$ then decrease the population counter by 1. All the adults and the children who failed then waits to be carried to Molokai.\\
  \item There is a global lock which all people except for $R$ and $D$ are waiting to acquire. If one person acquired the lock, he calls $R$ and $D$ to carry him to Molokai via one of the two subrountines, depending on whether it is a child or an adult. Then it decreases the population by 1, release the lock, and returns.\\
  \item At the end no one except $R$ and $D$ is running, and the population counter is 0. Then $R$ and $D$ perform the final rowing to Molokai and returns.
\end{asparaitem}

\subsection{Pseudocode}
The global variables we need are as follows:
\begin{asparaitem}
  \item \texttt{boolean isRowerSet}: The flag indicating if $R$ is set to a thread. All other threads should be able to access this.\\ 
  \item \texttt{boolean isRiderSet}: The $D$ thread. All other threads should be able to wake them up and call it.\\
  \item \texttt{int population}: The population counter, initially set to 0. Whenever a person is created, this counter increases by 1; whenever a person is assigned a role or get across the sea, the counter decreased by 0.\\
\end{asparaitem}

Furthermore, we need the following locks and condition variables to achieve the goal:\\
\begin{asparaitem}
  \item \texttt{Lock ChildMove \& Lock AllMove}: During initialization of the threads, no person should be able to move, as they may incorrectly determine the situation that no one is present on Oahu as the final state if the forking of threads goes too slow. Therefore, we use locks \texttt{ChildMove} and \texttt{AllMove} to block all threads but the main one to assure safe conditioning.\\
  \item \texttt{Lock End \& Condition CVEnd}: The lock and its corresponding condition variable which informs the main thread to quit. The $R$ thread will take charge of this lock until all people are across the sea.\\
  \item \texttt{Lock RowerMove, Condition CVRowerMove \& Lock RiderMove, Condition CVRiderMove}: These two locks are designed to synchronize the protocol between $R$, $D$ and the person being carried. Note that there can only be one person who is waiting for the lock, or it will cause problem.\\
  \item \texttt{Lock BeingCarried}: The lock held by the person being carried across the sea. Note that there can only be one thread holding it.\\
  \item \texttt{Lock PollMutex}: The lock held by the child who is trying to be $R$ or $D$.\\
\end{asparaitem}

Then the pseudocode for the main thread is as follows:

\begin{algorithm}
  \caption{Program performed by the main thread \texttt{begin(int adults, int children, BoatGrader b)}}
\begin{algorithmic}[1]
  \STATE Initialize all global variables\\
  \STATE \texttt{ChildMove.acquire()}; \COMMENT{Before forking threads, first acquire the locks to make sure to block them all}\\
\STATE \texttt{AllMove.acquire()};\\
\FOR {$i = 1$ to $adults$}
\STATE Fork a new thread running \texttt{AdultItinerary();}\\
\ENDFOR
\FOR {$i = 1$ to $children$}
\STATE Fork a new thread running \texttt{ChildrenItinerary();}\\
\ENDFOR
\STATE \texttt{End.acquire();}\\
\STATE \texttt{ChildMove.release();}\COMMENT{Unblock all children and let them elect $R$ and $D$}\\
\STATE \texttt{CVEnd.sleep();}\\
\STATE \texttt{AllMove.release();}\COMMENT{When woke up by already elected $R$, Unblock all threads and start crossing the river}\\
\STATE \texttt{CVEnd.wake();}\COMMENT{Wake up $R$ thread which woke it up}\\
\STATE \texttt{CVEnd.sleep();}\\
\STATE \texttt{End.release();}\COMMENT{When woke up by $R$ and informed that crossing is over, prepares to return}\\
\RETURN
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Program performed by an adult}
\begin{algorithmic}[1]
  \STATE \texttt{population ++;}\\
  \STATE \texttt{AllMove.acquire();}\\
  \STATE \texttt{AllMove.release();}\COMMENT{Releases to wake up still waiting threads}\\
  \STATE \texttt{BeingCarried.acquire();}\\
  \STATE \texttt{isAdult}=\TRUE;\\
  \STATE \texttt{RowerMove.acquire();}\COMMENT{Controls $R$ to perform the protocol for adult to cross the sea}\\
  \STATE \texttt{CVRowerMove.wake();}\\
  \STATE \texttt{CVRowerMove.sleep();}\\
  \STATE \texttt{bg.AdultRowToMolokai();}\\
  \STATE \texttt{CVRowerMove.wake();}\\
  \STATE \texttt{CVRowerMove.sleep();}\\
  \STATE \texttt{population --;}\\
  \STATE \texttt{CVRowerMove.wake();}\\
  \STATE \texttt{RowerMove.release();}\\
  \STATE \texttt{BeingCarried.release();}\\
  \STATE \texttt{\RETURN}\\
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{Program performed by children}
\begin{algorithmic}[1]
  \STATE \texttt{population ++;}\\
  \STATE Set \texttt{boolean isRower} = \FALSE, \texttt{isRider} = \FALSE;\\
  \STATE \texttt{ChildMove.acquire();}\COMMENT{Releases to still waiting children}\\
  \STATE \texttt{ChildMove.release();}\\
  \STATE \texttt{PollMutex.acquire();}\\
  \IF {\texttt{isRowerSet}=\FALSE}
   \STATE \texttt{isRowerSet}=\TRUE;\\
  \STATE \texttt{isRower}=\TRUE;\\
  \STATE \texttt{population --;}\\
  \ELSIF {\texttt{isRiderSet}=\FALSE} 
  \STATE \texttt{isRiderSet}=\TRUE;\\
  \STATE \texttt{isRider}=\TRUE;\\
  \STATE \texttt{population --;}\\
  \ENDIF
  \STATE \texttt{PollMutex.release();}\\
  \IF {\texttt{isRower}=\TRUE}
  \STATE \texttt{Rower();}\\
  \RETURN
  \ELSIF {\texttt{isRider}=\TRUE }
  \STATE \texttt{Rider();}
  \RETURN
  \ELSE
  \STATE \texttt{AllMove.acquire();}\\
  \STATE \texttt{AllMove.release();}\\
  \STATE \texttt{BeingCarried.acquire();}\\
  \STATE \texttt{isAdult}=\FALSE;\\
  \STATE \texttt{RowerMove.acquire();}\\
  \STATE \texttt{CVRowerMove.wake()};\\
  \STATE \texttt{CVRowerMove.sleep();}\\
  \STATE \texttt{bg.ChildrenRideToMolokai();}\\
  \STATE \texttt{CVRowerMove.wake();}
  \STATE \texttt{CVRowerMove.sleep();}\\
  \STATE \texttt{population --;}\\
  \STATE \texttt{CVRowerMove.wake();}\\
  \STATE \texttt{RowerMove.release();}
  \STATE \texttt{BeingCarried.release();}
  \RETURN
  \ENDIF
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{The method \texttt{Rower()}}
  \begin{algorithmic}
    
  \STATE \texttt{End.acquire();}\COMMENT{The $R$ thread is taking charge of the end condition lock}\\
  \STATE \texttt{RowerMove.acquire();}\\
  \STATE \texttt{RiderMove.acquire();}\\
  \STATE \texttt{CVEnd.wake();}\COMMENT{Wake up the main thread}\\
  \STATE \texttt{CVEnd.sleep();}\\
  \WHILE{\texttt{population} $\geq 1$}
  \STATE \texttt{CVRowerMove.sleep();}\COMMENT{Prepares to carry people across the sea}\\
  \IF{\texttt{isAdult}=\TRUE}
  \STATE \texttt{bg.ChildRowToMolokai();}\\
  \STATE \texttt{CVRiderMove.wake();}\\
  \STATE \texttt{CVRiderMove.sleep();}\\
  \STATE \texttt{CVRowerMove.wake();}\\
  \STATE \texttt{CVRowerMove.sleep();}\\
  \STATE \texttt{bg.ChildRowToOahu();}\\
  \STATE \texttt{CVRowerMove.wake();}\\
  \STATE \texttt{CVRowerMove.sleep();}\\
  \ELSE
  \STATE \texttt{bg.ChildRowToMolokai();}\\
  \STATE \texttt{CVRowerMove.wake();}\\
  \STATE \texttt{CVRowerMove.sleep();}\\
  \STATE \texttt{bg.ChildRowToOahu();}\\
  \STATE \texttt{CVRowerMove.wake();}\\
  \STATE \texttt{CVRowerMove.sleep();}\\
  \ENDIF
  \ENDWHILE
  \STATE \texttt{RowerMove.release();}\COMMENT{Wakes up the last person}\\
  \STATE \texttt{bgChildRowToMolokai();}\\
  \STATE \texttt{CVRiderMove.wake();}\\
  \STATE \texttt{CVRiderMove.sleep();}\\
  \STATE \texttt{RiderMove.release();}\\
  \STATE \texttt{CVEnd.wake();}\\
  \STATE \texttt{End.release();}\\
  \RETURN
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{The method \texttt{Rider()}}
  \begin{algorithmic}
  \STATE \texttt{AllMove.acquire();}\\
  \STATE \texttt{AllMove.release();}\\
  \STATE \texttt{RiderMove.acquire();}\\
  \STATE \texttt{CVRiderMove.sleep();}\COMMENT{Ready to be called by $R$}\\
  \WHILE {\texttt{population} $\geq 1$}
  \STATE\texttt{bg.ChildRideToMolokai();}\\
  \STATE\texttt{bg.ChildRowToOahu()};\\
  \STATE\texttt{CVRiderMove.wake();}\\
  \STATE\texttt{CVRiderMove.sleep();}\\
  \ENDWHILE
  \STATE\texttt{bg.ChildRideToMolokai();}\\
  \STATE\texttt{CVRiderMove.wake();}
  \STATE\texttt{RiderMove.release();}
  \RETURN
    
  \end{algorithmic}
\end{algorithm}

\end{spacing}
\end{document}
