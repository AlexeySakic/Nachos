\documentclass{article}
\usepackage{amsmath,amsfonts,amsthm,amssymb}
\usepackage{setspace}
\usepackage{paralist}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{extramarks}
\usepackage{chngpage}
\usepackage{indentfirst}
% \usepackage{soul,color}
\usepackage{graphicx,float,wrapfig}
\usepackage{mathrsfs}
\usepackage{algorithm}
\usepackage{algorithmic}
% \usepackage{tikz}
% \usepackage{pgffor}
\newcommand{\xd}{\leqslant}
\newcommand{\dd}{\geqslant}
% In case you need to adjust margins:
\topmargin=-0.45in      %
\evensidemargin=0in     %
\oddsidemargin=0in      %
\textwidth=6.5in        %
\textheight=9.0in       %
\headsep=0.25in         %

% Setup the header and footer
\pagestyle{fancy}                                                       %
% \lhead{\StudentName}                                                 %
\chead{\Title}  %
%\rhead{\firstxmark}                                                     %
\lfoot{\lastxmark}                                                      %
\cfoot{}                                                                %
\rfoot{Page\ \thepage\ of\ \protect\pageref{LastPage}}                          %
\renewcommand\headrulewidth{0.4pt}                                      %
\renewcommand\footrulewidth{0.4pt}                                      %

\newcommand{\Proof}{\ \\\textbf{Proof:} }
\newcommand{\Answer}{\ \\\textbf{Answer:} }
\newcommand{\Acknowledgement}[1]{\ \\{\bf Acknowledgement:} #1}

\makeatletter
\newcommand{\rmnum}[1]{\romannumeral #1}
\newcommand{\Rmnum}[1]{\expandafter\@slowromancap\romannumeral #1@}
\makeatother
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Make title
\newcommand{\Class}{Operating System}
\newcommand{\ClassInstructor}{Xu Wei}

% Homework Specific Information. Change it to your own
\newcommand{\Title}{Nachos Phase 2 Design Document}
\newcommand{\DueDate}{April 1, 2014}
\title{\textmd{\bf \Class: \Title}\\{\large Instructed by \textit{\ClassInstructor}}\\\normalsize\vspace{0.1in}\small{Due\ on\ \DueDate}}
\date{}

\author{%
  Huang JiaChen 2011012358 \and
  Wu YueXin 2011012061 \and
  Yang Sheng 2011012359 \and
  Yin HeZheng 2011012343 \and
  Zhou XuRen 2011012353}
\newcommand{\StudentClass}{Yao Class}

% \author{\textbf{\StudentName}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \begin{document}
  \begin{spacing}{1.1}
    \maketitle \thispagestyle{empty}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Begin edit from here

 
\section{Task 1}
\subsection{Overview}
Task 1 asks us to implement file system calls  in Nachos by adding code to the \texttt{UserProcess} class. Here we are not asked to implement a file system from scratch, but to give user processes the ability to access a file system that have been implemented.

The main requirements of the task can be divided into two categories: those to implement functionality, and those to ensure security.

To implement functionality, we need to add additional attributes (file descriptors, file states, etc.) and additional system call handler methods. As system calls are already declared in the header \texttt{text/syscall.h}, we don't need to consider how to design the interface and we can just focus on the internal implementation inside the class \texttt{UserProcess}. Also, an example method \texttt{UserProcess.halt} has been implemented, which gives us yet more hints.

For security constraints, we need to bullet-proof the Nachos kernel from user processes. We need to ensure that exceptions occurred inside the user process will not crash the system, and we also need to ensure that \texttt{halt()} can terminate the system only if it is called by the root process. Therefore we need some more attributes (e.g. pids) to distinguish process from process.

\subsection{Correctness Constraints}

\begin{asparaitem}
\item Implement the system calls: \texttt{create}, \texttt{open}, \texttt{read}, \texttt{write}, \texttt{close} and \texttt{unlink}\\
\item Bullet-proof the Nachos Kernel from user program errors: validating input and ensuring that errors are handled gracefully\\
\item Error condition of a system call should be indicated by a return value of -1 instead of throw an exception within the kernel\\
\item Ensure that halt can only be called from the root process (the first process in the system)\\
\item Each file that a process has opened should have a unique file descriptor associated with it.\\
\item When any process is started, its file descriptors 0 and 1 must refer to standard input and standard output.\\
\item 16 files should be able to be opened simultaneously in a single process
\end{asparaitem}

\subsection{Declarations}

We use \texttt{LinkedList<PriorityQueue> waitBy} and \texttt{PriorityQueue waitOn} to store threads waiting us and threads we are waiting separately. The class \texttt{PriorityQueue} is implemented by java.util.PriorityQueue.

\subsection{Descriptions}

The following algorithm describes the implementation of \texttt{getEffectivePriority} in high level.

\begin{algorithm}
  \caption{calculate effective priority}
\begin{algorithmic}[1]
  \STATE Initialize EP and donatorEP as default priority
  \STATE EP $\leftarrow$ priority
\FORALL {wait queues whose resource has been acquired by me}
  \STATE donatorEP $\leftarrow$ largest EP in that wait queue
  \IF {donatorEP $>$ EP}
    \STATE EP $\leftarrow$ donatorEP
  \ENDIF
\ENDFOR
\STATE recursively call calculate effective priority on the thread I am waiting on
\RETURN EP
\end{algorithmic}
\end{algorithm}

To clarify how we manipulate data structure, we illustrate the implementation of function \linebreak \texttt{PriorityQueue.waitForAccess}, \texttt{PriorityQueue.acquire} and \texttt{PriorityQueue.nextThread} (actually, \linebreak \texttt{waitForAccess} and \texttt{acquire} are implemented in class \texttt{ThreadState}).

\begin{algorithm}
  \caption{\texttt{ThreadState.wairForAccess(PriorityQueue waitQueue)}}
\begin{algorithmic}[1]
  \STATE waitQueue.add(this)  \COMMENT{add this thread to waitQueue}
  \STATE this.waitingOn $\leftarrow$ waitQueue  \COMMENT{update waitingOn queue}
  \STATE this.EP $\leftarrow$ calculateEffectivePriority()  \COMMENT{update EP}
\RETURN
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{\texttt{ThreadState.acquire(PriorityQueue waitQueue)}}
\begin{algorithmic}[1]
  \STATE waitQueue.owner $\leftarrow$ this
  \STATE this.waitingBy.insert(waitQueue)
  \STATE this.EP $\leftarrow$ calculateEffectivePriority()  \COMMENT{update EP}
\RETURN
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{\texttt{nextThread}}
\begin{algorithmic}[1]
  \STATE Initialize chosenThread as null
  \STATE chosenThread $\leftarrow$ pickNextThread()
  \IF {chosenThread != null}
    \STATE remove this queue from current owner's waitingBy list
    \STATE chosenThread.waitingOn $\leftarrow$ null
    \STATE insert this queue into chosenThread's waitingBy list
  \ENDIF
  \STATE this.owner $\leftarrow$ chosenThread
\RETURN chosenThread
\end{algorithmic}
\end{algorithm}

\subsection{Testing Plan}
We need to test the following things. The test is done in \texttt{selfTest()}
\begin{itemize}
\item The PriorityQueue of \texttt{java.util.PriorityQueue} works well(Automatically)
\item The transfer of priority works well
\item The transfer of priority will hold its property when queue updated
\item \texttt{Acquire()} will work well, and add queue to the queue list
\end{itemize}

\begin{algorithm}
  \caption{\texttt{selfTest}}
\begin{algorithmic}[1]
  \STATE Initialize a PriorityScheduler \texttt{s}
  \STATE Initialize 3 ThreadQueue
  \STATE Create 5 threads
  \STATE disable interrupt
  \STATE
  \STATE queue1.acquare(thread1)
  \STATE queue2.acquire(thread1)
  \STATE queue1.waitForAccess(thread2)
  \STATE queue3.acquire(thread3)
  \STATE queue3.waitForAccess(thread1)
  \STATE print all the information of the threads
  \STATE
  \STATE thread2.setPriority(3)
  \STATE print all the information of the threads
  \STATE
  \STATE queue2.waitForAccess(thread4)
  \STATE thread3.setPriority(5)
  \STATE print all the information of the threads
  \STATE
  \STATE thread3.setPriority(2)
  \STATE print all the information of the threads
  \STATE
  \STATE restore interrupt
\end{algorithmic}
\end{algorithm}


\end{spacing}
\end{document}
