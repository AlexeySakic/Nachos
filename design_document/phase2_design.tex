\documentclass{article}
\usepackage{amsmath,amsfonts,amsthm,amssymb}
\usepackage{setspace}
\usepackage{paralist}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{extramarks}
\usepackage{chngpage}
\usepackage{indentfirst}
\usepackage{soul,color}
\usepackage{graphicx,float,wrapfig}
\usepackage{mathrsfs}
\usepackage{algorithm}
\usepackage{algorithmic}
% \usepackage{tikz}
% \usepackage{pgffor}
\newcommand{\eq}{$\leftarrow$}
% In case you need to adjust margins:
\topmargin=-0.45in      %
\evensidemargin=0in     %
\oddsidemargin=0in      %
\textwidth=6.5in        %
\textheight=9.0in       %
\headsep=0.25in         %

% Setup the header and footer
\pagestyle{fancy}                                                       %
% \lhead{\StudentName}                                                 %
\chead{\Title}  %
%\rhead{\firstxmark}                                                     %
\lfoot{\lastxmark}                                                      %
\cfoot{}                                                                %
\rfoot{Page\ \thepage\ of\ \protect\pageref{LastPage}}                          %
\renewcommand\headrulewidth{0.4pt}                                      %
\renewcommand\footrulewidth{0.4pt}                                      %

\newcommand{\Proof}{\ \\\textbf{Proof:} }
\newcommand{\Answer}{\ \\\textbf{Answer:} }
\newcommand{\Acknowledgement}[1]{\ \\{\bf Acknowledgement:} #1}

\makeatletter
\newcommand{\rmnum}[1]{\romannumeral #1}
\newcommand{\Rmnum}[1]{\expandafter\@slowromancap\romannumeral #1@}
\makeatother
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Make title
\newcommand{\Class}{Operating System}
\newcommand{\ClassInstructor}{Xu Wei}

% Homework Specific Information. Change it to your own
\newcommand{\Title}{Nachos Phase 2 Design Document}
\newcommand{\DueDate}{April 1, 2014}
\title{\textmd{\bf \Class: \Title}\\{\large Instructed by \textit{\ClassInstructor}}\\\normalsize\vspace{0.1in}\small{Due\ on\ \DueDate}}
\date{}

\author{%
  Huang JiaChen 2011012358 \and
  Wu YueXin 2011012061 \and
  Yang Sheng 2011012359 \and
  Yin HeZheng 2011012343 \and
  Zhou XuRen 2011012353}
\newcommand{\StudentClass}{Yao Class}

\definecolor{myyellow}{RGB}{255, 255, 60}

% \author{\textbf{\StudentName}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  \begin{document}
  \begin{spacing}{1.1}
    \maketitle \thispagestyle{empty}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Begin edit from here


\section{Task 1}
\subsection{Overview}
Task 1 asks us to implement file system calls  in Nachos by adding code to the \texttt{UserProcess} class. Here we are not asked to implement a file system from scratch, but to give user processes the ability to access a file system that have been implemented.

The main requirements of the task can be divided into two categories: those to implement functionality, and those to ensure security.

To implement functionality, we need to add additional attributes (file descriptors, file states, etc.) and additional system call handler methods. As system calls are already declared in the header \texttt{text/syscall.h}, we don't need to consider how to design the interface and we can just focus on the internal implementation inside the class \texttt{UserProcess}. Also, an example method \texttt{UserProcess.halt} has been implemented, which gives us yet more hints.

For security constraints, we need to bullet-proof the Nachos kernel from user processes. We need to ensure that exceptions occurred inside the user process will not crash the system, and we also need to ensure that \texttt{halt()} can terminate the system only if it is called by the root process. Therefore we need some more attributes (e.g. pids) to distinguish process from process.

\subsection{Correctness Constraints}

\begin{asparaitem}
\item Implement the system calls: \texttt{create}, \texttt{open}, \texttt{read}, \texttt{write}, \texttt{close} and \texttt{unlink}\\
\item Bullet-proof the Nachos Kernel from user program errors: validating input and ensuring that errors are handled gracefully\\
\item Error condition of a system call should be indicated by a return value of -1 instead of throw an exception within the kernel\\
\item Ensure that halt can only be called from the root process (the first process in the system)\\
\item Each file that a process has opened should have a unique file descriptor associated with it.\\
\item When any process is started, its file descriptors 0 and 1 must refer to standard input and standard output.\\
\item 16 files should be able to be opened simultaneously in a single process
\end{asparaitem}

\subsection{Declarations}

We use \texttt{OpenFile[] fileDesriptorTable} to store the 16 files opened by this process.

\subsection{Descriptions}

The following algorithm describes the implementation in high level.

\begin{algorithm}
  \caption{int \texttt{handleHalt}()}
\begin{algorithmic}[1]
  \IF { processID != 0}
    \RETURN 0
  \ENDIF
  \STATE \texttt{Machine.halt()}
  \RETURN 0
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{int \texttt{handleCreate}(int vaddr)}
\begin{algorithmic}[1]
  \IF { vaddr is invalid}
    \RETURN -1
  \ENDIF
  \STATE filename $\leftarrow$ \texttt{readVirtualMemoryString}(vaddr, 256)
  \IF { filename is invalid}
    \RETURN -1
  \ENDIF
  \IF {$\exists$ free file descriptor $x$}
    \STATE file $\leftarrow$ \texttt{ThreadedKernel.fileSystem.open}(filename, false)
    \STATE fileDescriptorTable[x] $\leftarrow$ file
    \RETURN $x$
  \ELSE
    \RETURN -1
  \ENDIF
\end{algorithmic}
\end{algorithm}

To implemente \texttt{handleOpen}, we only need to change line 9 of \texttt{handleCreate} to following:
\begin{algorithm}
  \caption{int \texttt{handleOpen}(int vaddr)}
\begin{algorithmic}[1]
 \IF { vaddr is invalid}
    \RETURN -1
  \ENDIF
  \STATE filename $\leftarrow$ \texttt{readVirtualMemoryString}(vaddr, 256)
  \IF { filename is invalid}
    \RETURN -1
  \ENDIF
  \IF {$\exists$ free file descriptor $x$}
    \STATE \colorbox{myyellow}{file $\leftarrow$ \texttt{ThreadedKernel.fileSystem.open}(filename, true)}
    \STATE fileDescriptorTable[x] $\leftarrow$ file
    \RETURN $x$
  \ELSE
    \RETURN -1
  \ENDIF
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{int \texttt{handleRead}(int fileDescriptor, int bufferAddr, int count)}
\begin{algorithmic}[1]
 \IF { fileDescriptor is invalid}
    \RETURN -1
  \ENDIF
  \STATE file $\leftarrow$ \texttt{fileDescriptorTable}[fileDesriptor]
  \IF { file is invalid $||$ count $<$ 0}
    \RETURN -1
  \ENDIF
  \STATE Initialize buffer to read from file
  \STATE bytesRead $\leftarrow$ file.\texttt{read}(buffer, 0, count)
  \IF {bytesRead $==$ -1}
    \RETURN -1
  \ELSE
    \STATE bytesReturn $\leftarrow$ \texttt{writeVirtualMemory(bufferAddr, buffer, 0, bytesRead)}
    \RETURN bytesReturn
  \ENDIF
\end{algorithmic}
\end{algorithm}

\texttt{handWrite} is quite similar to \texttt{handleRead}:

\begin{algorithm}
  \caption{int \texttt{handleWrite}(int fileDescriptor, int bufferAddr, int count)}
\begin{algorithmic}[1]
 \IF { fileDescriptor is invalid}
    \RETURN -1
  \ENDIF
  \STATE file $\leftarrow$ \texttt{fileDescriptorTable}[fileDesriptor]
  \IF { file is invalid $||$ count $<$ 0}
    \RETURN -1
  \ENDIF
  \STATE Initialize buffer to read from virtual memory
  \STATE bytesWritten $\leftarrow$ \texttt{readVirtualMemory}(bufferAddr, buffer, 0, count)
  \IF {bytesWritten != count}
    \RETURN -1
  \ENDIF
  \STATE bytesReturn $\leftarrow$ file.\texttt{write}(buffer, 0, bytesWritten)
  \IF {bytesReturn != count}
    \RETURN -1
  \ENDIF
  \RETURN bytesReturn
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{int \texttt{handleClose}(int fileDescriptor)}
\begin{algorithmic}[1]
 \IF { fileDescriptor is invalid}
    \RETURN -1
  \ENDIF
  \STATE \texttt{fileDescriptorTable}[fileDesriptor].\texttt{close}()
  \STATE  \texttt{fileDescriptorTable}[fileDesriptor] $\leftarrow$ null
  \RETURN 0
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{int \texttt{handleUnlink}(string name)}
\begin{algorithmic}[1]
  \STATE  success $\leftarrow$ \texttt{ThreadedKernel.fileSystem.remove}(name)
 \IF { ! success}
    \RETURN -1
  \ENDIF
  \RETURN 0
\end{algorithmic}
\end{algorithm}



\subsection{Testing Plan}



\section{Task 3}
\subsection{Overview}
In Task 2, we have to implement three system calls (\texttt{exec, join} and \texttt{exit}) as documented in \texttt{syscall.h}. All of them require us to add codes for \texttt{handleSyscall} in class \texttt{UserProcess}.

For \texttt{exec}, we have to create a subprocess and run its \texttt{execute()} function and create standard input output file descriptors.

As \texttt{join} deals with subprocesses and can only be used between parents and children, we need to use references to record a process's parent process and a list for its children. And when the function is called, we have to check by using \texttt{UserKernel.currentProcess()} in case of illegal joins.

And when \texttt{exit} is called, we also need to free up memory, close open files and also inform the parent process of the information so that \texttt{join} can no longer be called. We also have to notify its subprocesses the termination. Besides, since the last process calling \texttt{exit} should invoke \texttt{Kernel.kernel.terminate()}, we should keep a global list making sure that we know which one to do the closing.

Notice that we do not have to modify \texttt{Uthread.finish()} to do the same closing, since as is suggested in file \texttt{start.s}, a normal return from \texttt{main()} would call \texttt{exit} at last. Thus, we only need to care unhandled exceptions and \texttt{exit}. And the process ID is distributed at the construction function of the process.
\subsection{Correctness Constraints}
\begin{asparaitem}
  \item \texttt{exec} and \texttt{join} will first check the validity of its input, and \texttt{join} would make sure of the legitimacy of the caller and the callee.
  \item References of parents and children are kept in case of \texttt{join}.
  \item A global list is kept to record which process is the last to call \texttt{exit}.
  \item Cleanups are done both in \texttt{exit} and unhandled exceptions.
\end{asparaitem}
\subsection{Declarations}
\texttt{private boolean normalExit} for whether the program exits normally

\texttt{private in exitStatus} for the simplicity of transferring the status to its joining parent

\texttt{private UserProcess parentProcess} is the reference to its parent (\texttt{null} as default)

\texttt{private static int nextProcessID} denotes the next process ID to assign

\texttt{private int processID} denotes the ID assigned to ``this'' process

\texttt{private static HashMap<Integer, UserProcess> userProcessList} denotes the list containing all main processes (without fathers)

\texttt{private LinkedList<UserProcess> childProcessList} denotes the list containing all child processes of ``this'' process

\texttt{private Semaphore joinSemaphore} denotes the semaphore used in function \texttt{join}

\subsection{Descriptions}
\begin{algorithm}
\caption{int \texttt{handleExec}(int file, int argc, int argv)}
  \begin{algorithmic}
    \IF {(fileDescriptorTable = new OpenFile[16]) is invalid}
      \RETURN -1
    \ENDIF
    \STATE fileDescriptorTable[0] = UserProcess.console.openForReading()
    \STATE fileDescriptorTable[1] = UserProcess.console.openForWriting()
    \STATE fileName\eq\texttt{readVirtualMemoryString}(file,256)
    \IF {(fileDescriptorTable[0,1] is invalid) or (fileName is invalid) or (argc $<$ 0)}
      \RETURN -1
    \ENDIF
    \IF {fileName does not end with \texttt{.coff}}
      \RETURN -1
    \ENDIF
      \STATE String[] args = new String[argc]
      \FOR {i = 0; i $<$ argc; i++}
        \STATE args[i]\eq\texttt{readVirtualMemoryString(argv, 256)}
        \IF {args[i] == \texttt{null}}
          \RETURN -1
        \ENDIF
        \STATE {\color{blue}//since $\backslash0$  occupies one char}
        \STATE argv += args[i].length + 1
      \ENDFOR
    \STATE UserProcess childProcess = new UserProcess()
    \IF {childProcess is not valid}
      \RETURN -1
    \ENDIF
    \STATE childProcess.setParent(this)
    %%??
    \STATE childProcessList.add(childProcess);
    \STATE userProcessTable.put(childProcess.getID(), childProcess)
    \IF {not child.\texttt{execute}(fileName, args)}
      \RETURN -1
    \ENDIF
    \RETURN childProcess.getID()
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{boolean \texttt{join}(int status)}
  \begin{algorithmic}
    \STATE {\color{blue} //note that we have to keep both exitStatus and normalExit since the exit status is not required to be consistent with a normal exit}
    \STATE joinSemaphore.P()
    \STATE {\color{blue} //assume an integer is of 4 bytes and the processor is little endian}
    \STATE byte[] data = new byte[4]
    \FOR {i = 0; i $<$ 4; i++}
      \STATE data[3 - i] = status $>>$ (i * 8)
    \ENDFOR
    \STATE writeVirtualMemory(status, data)
    \STATE joinSemaphore.V()
    \RETURN normalExit
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{int \texttt{HandleJoin}(int processID, int status)}
  \begin{algorithmic}
    \STATE {\color{blue}//check validity}
    \STATE UserProcess joinProcess = userProcessTable.get(processID)
    \IF {not (joinProcess.parent.getID() == UserThread.currentProcess().getID())}
      \RETURN -1
    \ENDIF
    \IF {joinProcess.join(status)}
      \RETURN 1
    \ENDIF
    \RETURN 0
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{void \texttt{cleanUp}()}
  \begin{algorithmic}
    \FOR {file in fileDesriptorTable}
      \STATE {handleClose(file)}
    \ENDFOR
    \FOR {child in childProcessList}
      \STATE child.setParent(null)
    \ENDFOR
    \STATE \colorbox{myyellow}{need free up memory!}
    \STATE userProcessTable.remove(UserThread.getCurrentProcess().getID())
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{void \texttt{HandleExit}(int status, boolean normalExit)}
  \begin{algorithmic}
    \STATE {\color{blue}// we also use this function to handle unhandled exceptions except that we manually set status}
    \STATE \texttt{cleanUp}()
    \IF {userProcessTable.isEmpty()}
      \STATE UserKernel.kernel.terminate()
    \ENDIF
    \STATE exitStatus = status
    \STATE this.normalExit = normalExit
    \STATE joinSemaphore.V()
  \end{algorithmic}
\end{algorithm}

\subsection{Testing Plan}
\begin{asparaitem}
  \item A program with $argc=0$.
  \item Processes killed midway to test whether the parent can receive the correct information and make sure that the cleanups are correctly done.
  \item Console for inputs and outputs can not be established (???the first step needs check).
  \item Interrupt at userProcessTable putting in new pairs???
  \item whether use equals of java object???
  \item join on a finished process
\end{asparaitem}

\section{Task 4}

\subsection{Overview}
In task 4, we need to implement a lottery scheduler which extends \texttt{PriorityScheduler}. In lottery scheduling, tickets are used to represent the share of a resource that a process(or thread) should receive. So instead of donating priority, waiting threads transfer tickets to threads they wait for. The major difference is that a waiting thread always adds its ticket count to the ticket count of the current queue owner; that is, the owner's ticket count is the sum of its own tickets and the tickets of all its waiters, not the max.

To implements this feature, we have to override \texttt{nextThread} method of class \texttt{PriorityThreadedQueue} and \texttt{updateEffectivePriority} method of class \texttt{ThreadState} and add some short helper methods. We override \texttt{nextThread} method in order to hold a lottery when \texttt{PriorityThreadedQueue} is going to pick a thread from its \texttt{PriorityQueue}. We override \texttt{updateEffectivePriority} to calculate the EP by taking sum instead of taking max.

\subsection{Correctness Constraints}

\subsection{Declaration}

\subsection{Description}

\subsection{Testing Plan}


\end{spacing}
\end{document}
